[{"name":"index.ts","content":"// smart-endpoint/index.ts\r\nimport \"jsr:@supabase/functions-js/edge-runtime.d.ts\"\r\nimport { createClient } from \"jsr:@supabase/supabase-js@2\"\r\nimport { SYMBOLS, Timeframe, inferSignalType } from './config.ts'\r\nimport { buildFactorSnapshot, generateSignal } from './engine.ts'\r\n\r\nconst DEFAULT_TIMEFRAMES: Timeframe[] = ['5m', '15m', '1h', '4h', '1d']\r\n\r\nfunction normalizeTimeframe(value: unknown): Timeframe | null {\r\n  if (typeof value !== \"string\") return null\r\n  const tf = value.toLowerCase().trim()\r\n  switch (tf) {\r\n    case \"5m\":\r\n    case \"5min\":\r\n    case \"5\":\r\n      return \"5m\"\r\n    case \"15m\":\r\n    case \"15min\":\r\n    case \"15\":\r\n      return \"15m\"\r\n    case \"1h\":\r\n    case \"60m\":\r\n    case \"60min\":\r\n    case \"1hour\":\r\n      return \"1h\"\r\n    case \"4h\":\r\n    case \"240m\":\r\n    case \"4hour\":\r\n      return \"4h\"\r\n    case \"1d\":\r\n    case \"daily\":\r\n    case \"1day\":\r\n      return \"1d\"\r\n    default:\r\n      return null\r\n  }\r\n}\r\n\r\nconst SUPABASE_URL = Deno.env.get(\"SUPABASE_URL\")\r\nconst SUPABASE_SERVICE_ROLE_KEY = Deno.env.get(\"SUPABASE_SERVICE_ROLE_KEY\")\r\n\r\nDeno.serve(async (req) => {\r\n  if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {\r\n    return new Response(\"Missing env vars\", { status: 500 })\r\n  }\r\n  \r\n  const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, {\r\n    auth: { persistSession: false }\r\n  })\r\n  \r\n  // Parse request (e.g. for specific timeframe cron)\r\n  let targetTimeframes: Timeframe[] = DEFAULT_TIMEFRAMES\r\n  try {\r\n    const body = await req.json()\r\n    if (body?.timeframes) {\r\n      const normalized = (Array.isArray(body.timeframes) ? body.timeframes : [body.timeframes])\r\n        .map(normalizeTimeframe)\r\n        .filter((tf): tf is Timeframe => Boolean(tf))\r\n      if (normalized.length > 0) {\r\n        targetTimeframes = normalized\r\n      }\r\n    } else if (body?.timeframe) {\r\n      const tf = normalizeTimeframe(body.timeframe)\r\n      if (tf) {\r\n        targetTimeframes = [tf]\r\n      }\r\n    }\r\n  } catch {}\r\n\r\n  if (!Array.isArray(targetTimeframes) || targetTimeframes.length === 0) {\r\n    targetTimeframes = DEFAULT_TIMEFRAMES\r\n  }\r\n  \r\n  const results = []\r\n  const errors = []\r\n  \r\n  // Iterate symbols\r\n  for (const config of SYMBOLS) {\r\n    // Only process timeframes enabled for this symbol AND requested\r\n    const timeframes = config.enabledTimeframes.filter(tf => targetTimeframes.includes(tf))\r\n    \r\n    for (const tf of timeframes) {\r\n      try {\r\n        const snapshot = await buildFactorSnapshot(config.symbol, tf)\r\n        if (!snapshot) continue\r\n        const candidate = generateSignal(snapshot)\r\n        if (!candidate) continue\r\n        \r\n        const signal = {\r\n          ...candidate,\r\n          symbol: config.symbol,\r\n          timeframe: tf,\r\n        }\r\n\r\n          // Check dedupe: symbol_id, timeframe, direction, status=active\r\n          // We need symbol_id first.\r\n          const { data: symData } = await supabase\r\n            .from('symbols')\r\n            .select('id')\r\n            .or(`fmp_symbol.eq.${config.symbol},display_symbol.eq.${config.symbol}`)\r\n            .single()\r\n            \r\n          if (!symData) {\r\n            errors.push(`Symbol not found in DB: ${config.symbol}`)\r\n            continue\r\n          }\r\n          \r\n          // Check existing\r\n          const { data: existing } = await supabase\r\n            .from('signals')\r\n            .select('id')\r\n            .eq('symbol_id', symData.id)\r\n            .eq('timeframe', tf)\r\n            .eq('direction', signal.direction)\r\n            .eq('status', 'active')\r\n            .maybeSingle()\r\n            \r\n          if (existing) {\r\n            // Skip or update? For now skip to avoid spam\r\n            continue\r\n          }\r\n          \r\n          // Insert\r\n          const { error: insErr } = await supabase.from('signals').insert({\r\n            symbol: signal.symbol,\r\n            symbol_id: symData.id,\r\n            direction: signal.direction,\r\n            type: inferSignalType(tf),\r\n            market: config.type,\r\n            entry: signal.entry,\r\n            sl: signal.stop,\r\n            tp1: signal.target,\r\n            tp2: signal.tp2,\r\n            tp3: signal.tp3,\r\n            target_price: signal.target,\r\n            rr: signal.rr,\r\n            timeframe: tf,\r\n            status: 'active',\r\n            score: signal.score,\r\n            quality_tier: signal.qualityTier,\r\n            regime: signal.regime,\r\n            factors: signal.factors,\r\n            explanation: signal.explanation,\r\n            engine_version: 'v2.1-edge',\r\n          })\r\n          \r\n          if (insErr) errors.push(`Insert error ${config.symbol}: ${insErr.message}`)\r\n          else results.push(signal)\r\n        }\r\n      } catch (e) {\r\n        errors.push(`Error processing ${config.symbol} ${tf}: ${String(e)}`)\r\n      }\r\n    }\r\n  }\r\n  \r\n  return new Response(JSON.stringify({\r\n    processed: results.length,\r\n    errors,\r\n    signals: results\r\n  }), { headers: { \"Content-Type\": \"application/json\" } })\r\n})\r\n"},{"name":"engine.ts","content":"/**\r\n * Engine Logic for Edge Function\r\n * Replicates lib/signals/engine.ts but for Deno\r\n */\r\n\r\nimport { Timeframe, SYMBOLS, RISK_CONFIG } from './config.ts'\r\nimport { FactorSnapshot, GeneratedSignalCandidate } from './factors.ts'\r\nimport { detectRegime } from './regime.ts'\r\nimport { scoreLong, scoreShort, calculateTotalScore } from './scoring.ts'\r\nimport { ema, rsi, macd, atr, sma, recentHighLow } from './indicators.ts'\r\n\r\ndeclare const Deno: {\r\n  env: {\r\n    get(key: string): string | undefined\r\n  }\r\n}\r\n\r\nconst FMP_API_KEY = Deno.env.get(\"FMP_API_KEY\")\r\nconst FMP_BASE = \"https://financialmodelingprep.com/api/v3\"\r\n\r\nasync function getFmpHistoricalCandles(symbol: string, timeframe: string, limit: number) {\r\n  if (!FMP_API_KEY) return []\r\n  try {\r\n    const url = `${FMP_BASE}/historical-chart/${timeframe}/${encodeURIComponent(symbol)}?apikey=${FMP_API_KEY}&limit=${limit}`\r\n    const res = await fetch(url)\r\n    if (!res.ok) return []\r\n    const data = await res.json()\r\n    return Array.isArray(data) ? data : []\r\n  } catch (e) {\r\n    console.error(\"FMP Error:\", e)\r\n    return []\r\n  }\r\n}\r\n\r\nexport async function buildFactorSnapshot(symbol: string, timeframe: Timeframe): Promise<FactorSnapshot | null> {\r\n  try {\r\n    const fmpTf = timeframe === '1h' ? '1hour' : timeframe === '4h' ? '4hour' : timeframe === '1d' ? '1day' : timeframe === '15m' ? '15min' : timeframe === '5m' ? '5min' : timeframe === '1m' ? '1min' : '1hour'\r\n    \r\n    const candles = await getFmpHistoricalCandles(symbol, fmpTf, 250)\r\n    if (!candles || candles.length < 200) return null\r\n    \r\n    const sortedCandles = [...candles].reverse()\r\n    const closes = sortedCandles.map((c: any) => c.close)\r\n    const highs = sortedCandles.map((c: any) => c.high)\r\n    const lows = sortedCandles.map((c: any) => c.low)\r\n    const volumes = sortedCandles.map((c: any) => c.volume)\r\n    \r\n    // VALIDATION: Sanity check price dynamically\r\n    const currentPrice = closes[closes.length - 1]\r\n    \r\n    // Basic zero check\r\n    if (!currentPrice || currentPrice <= 0) {\r\n      console.warn(`[Engine] Invalid price for ${symbol}: ${currentPrice}`)\r\n      return null\r\n    }\r\n\r\n    // Calculate EMA200 for validation\r\n    const ema200 = ema(closes, 200)\r\n    const ema200Now = ema200[ema200.length - 1]\r\n\r\n    // Dynamic validation: Price shouldn't deviate > 50% from EMA200\r\n    // This catches bad data (e.g. stock price for crypto) without hardcoded ranges\r\n    if (ema200Now && Math.abs(currentPrice - ema200Now) / ema200Now > 0.5) {\r\n      console.warn(`[Engine] Price deviation > 50% from EMA200 for ${symbol}. Price: ${currentPrice}, EMA200: ${ema200Now}. Likely bad data.`)\r\n      return null\r\n    }\r\n\r\n    const ema20 = ema(closes, 20)\r\n    const ema50 = ema(closes, 50)\r\n    const rsi14 = rsi(closes, 14)\r\n    const macdData = macd(closes)\r\n    const atr14 = atr(highs, lows, closes, 14)\r\n    const volAvg20 = sma(volumes, 20)\r\n    const { highs: highs20, lows: lows20 } = recentHighLow(highs, lows, 20)\r\n    const { highs: highs50, lows: lows50 } = recentHighLow(highs, lows, 50)\r\n    \r\n    const idx = closes.length - 1\r\n    \r\n    return {\r\n      symbol,\r\n      timeframe,\r\n      now: new Date(),\r\n      close: closes[idx],\r\n      ema20: ema20[ema20.length - 1],\r\n      ema50: ema50[ema50.length - 1],\r\n      ema200: ema200[ema200.length - 1],\r\n      rsi14: rsi14[rsi14.length - 1],\r\n      macdHist: macdData.histogram[macdData.histogram.length - 1],\r\n      macdHistSlope: macdData.histogram[macdData.histogram.length - 1] - macdData.histogram[macdData.histogram.length - 2],\r\n      atr: atr14[atr14.length - 1],\r\n      atrPct: atr14[atr14.length - 1] / closes[idx],\r\n      volume: volumes[idx],\r\n      volumeAvg20: volAvg20[volAvg20.length - 1],\r\n      volumeRatio: volumes[idx] / (volAvg20[volAvg20.length - 1] || 1),\r\n      high20: highs20[highs20.length - 1],\r\n      low20: lows20[lows20.length - 1],\r\n      high50: highs50[highs50.length - 1],\r\n      low50: lows50[lows50.length - 1]\r\n    }\r\n  } catch (error) {\r\n    console.error(`[Engine] Error building snapshot for ${symbol}:`, error)\r\n    return null\r\n  }\r\n}\r\n\r\nexport function generateSignal(f: FactorSnapshot): GeneratedSignalCandidate | null {\r\n  const regime = detectRegime(f)\r\n  const longScores = scoreLong(f, regime)\r\n  const shortScores = scoreShort(f, regime)\r\n  const longTotal = calculateTotalScore(longScores)\r\n  const shortTotal = calculateTotalScore(shortScores)\r\n  const THRESHOLD = 60\r\n  \r\n  let direction: 'LONG' | 'SHORT'\r\n  let scores\r\n  let totalScore\r\n  \r\n  if (longTotal >= shortTotal) {\r\n    direction = 'LONG'\r\n    scores = longScores\r\n    totalScore = longTotal\r\n  } else {\r\n    direction = 'SHORT'\r\n    scores = shortScores\r\n    totalScore = shortTotal\r\n  }\r\n  \r\n  if (totalScore < THRESHOLD) return null\r\n  \r\n  const atr = f.atr\r\n  if (!atr || atr <= 0) return null\r\n\r\n  // Lookup asset type risk config\r\n  const symConfig = SYMBOLS.find(s => s.symbol === f.symbol)\r\n  const riskCfg = symConfig ? RISK_CONFIG[symConfig.type] : { atrMultipleSL: 2.0, rrTarget: 2.0 } // Default fallback\r\n\r\n  const riskMultiple = riskCfg.atrMultipleSL\r\n  const rewardMultiple = riskCfg.rrTarget\r\n  \r\n  let stop, target, tp2, tp3\r\n  if (direction === 'LONG') {\r\n    stop = f.close - (atr * riskMultiple)\r\n    target = f.close + (atr * riskMultiple * rewardMultiple) // TP1\r\n    tp2 = f.close + (atr * riskMultiple * (rewardMultiple + 1)) // TP2 = TP1 + 1R\r\n    tp3 = f.close + (atr * riskMultiple * (rewardMultiple + 2)) // TP3 = TP1 + 2R\r\n  } else {\r\n    stop = f.close + (atr * riskMultiple)\r\n    target = f.close - (atr * riskMultiple * rewardMultiple) // TP1\r\n    tp2 = f.close - (atr * riskMultiple * (rewardMultiple + 1))\r\n    tp3 = f.close - (atr * riskMultiple * (rewardMultiple + 2))\r\n  }\r\n  \r\n  let qualityTier: 'A' | 'B' | 'C' = 'C'\r\n  if (totalScore >= 80) qualityTier = 'A'\r\n  else if (totalScore >= 70) qualityTier = 'B'\r\n  \r\n  const explanation = `${direction} ${regime.toUpperCase()} signal (Score: ${totalScore}). Trend: ${Math.round(scores.trendScore*100)}%, Mom: ${Math.round(scores.momentumScore*100)}%, Vol: ${Math.round(scores.volumeScore*100)}%`\r\n  \r\n  return {\r\n    direction,\r\n    score: totalScore,\r\n    qualityTier,\r\n    entry: f.close,\r\n    stop,\r\n    target, // This maps to tp1\r\n    tp2,\r\n    tp3,\r\n    rr: rewardMultiple,\r\n    regime,\r\n    factors: { ...f, factorScores: scores },\r\n    explanation\r\n  }\r\n}\r\n"},{"name":"config.ts","content":"/**\r\n * Signal Engine v2 Configuration\r\n */\r\n\r\nexport type InstrumentType = 'crypto' | 'forex' | 'index' | 'stock' | 'commodity' | 'metal'\r\n\r\nexport type Timeframe = '5m' | '15m' | '1h' | '4h' | '1d'\r\n\r\nexport type SignalStyle = 'scalp' | 'intraday' | 'swing'\r\n\r\nexport interface SymbolConfig {\r\n  symbol: string            // FMP Ticker\r\n  type: InstrumentType\r\n  enabledTimeframes: Timeframe[]\r\n}\r\n\r\nexport interface RiskConfig {\r\n  atrMultipleSL: number\r\n  rrTarget: number\r\n}\r\n\r\nexport const RISK_CONFIG: Record<InstrumentType, RiskConfig> = {\r\n  forex:     { atrMultipleSL: 1.5, rrTarget: 2.0 },\r\n  index:     { atrMultipleSL: 1.5, rrTarget: 1.8 },\r\n  stock:     { atrMultipleSL: 2.0, rrTarget: 2.5 },\r\n  crypto:    { atrMultipleSL: 2.5, rrTarget: 3.0 },\r\n  commodity: { atrMultipleSL: 2.0, rrTarget: 2.5 },\r\n  metal:     { atrMultipleSL: 1.5, rrTarget: 2.0 },\r\n}\r\n\r\n/**\r\n * Core symbol universe\r\n */\r\nexport const SYMBOLS: SymbolConfig[] = [\r\n  // Crypto\r\n  { symbol: 'BTCUSD', type: 'crypto', enabledTimeframes: ['5m', '15m', '1h', '4h'] },\r\n  { symbol: 'ETHUSD', type: 'crypto', enabledTimeframes: ['5m', '15m', '1h', '4h'] },\r\n  \r\n  // Forex - Major pairs\r\n  { symbol: 'EURUSD', type: 'forex', enabledTimeframes: ['5m', '15m', '1h', '4h'] },\r\n  { symbol: 'GBPUSD', type: 'forex', enabledTimeframes: ['5m', '15m', '1h', '4h'] },\r\n  { symbol: 'USDJPY', type: 'forex', enabledTimeframes: ['5m', '15m', '1h', '4h'] },\r\n  { symbol: 'USDCHF', type: 'forex', enabledTimeframes: ['5m', '15m', '1h', '4h'] },\r\n  { symbol: 'AUDUSD', type: 'forex', enabledTimeframes: ['5m', '15m', '1h', '4h'] },\r\n  { symbol: 'NZDUSD', type: 'forex', enabledTimeframes: ['5m', '15m', '1h', '4h'] },\r\n  { symbol: 'USDCAD', type: 'forex', enabledTimeframes: ['5m', '15m', '1h', '4h'] },\r\n  \r\n  // Commodities\r\n  { symbol: 'XAUUSD', type: 'metal', enabledTimeframes: ['5m', '15m', '1h', '4h'] },\r\n  { symbol: 'XAGUSD', type: 'metal', enabledTimeframes: ['5m', '15m', '1h', '4h'] },\r\n  { symbol: 'CLUSD', type: 'commodity', enabledTimeframes: ['15m', '1h', '4h', '1d'] },\r\n  \r\n  // Stocks\r\n  { symbol: 'NVDA', type: 'stock', enabledTimeframes: ['15m', '1h', '4h', '1d'] },\r\n  { symbol: 'AAPL', type: 'stock', enabledTimeframes: ['15m', '1h', '4h', '1d'] },\r\n  { symbol: 'MSFT', type: 'stock', enabledTimeframes: ['15m', '1h', '4h', '1d'] },\r\n  { symbol: 'GOOGL', type: 'stock', enabledTimeframes: ['15m', '1h', '4h', '1d'] },\r\n  { symbol: 'TSLA', type: 'stock', enabledTimeframes: ['15m', '1h', '4h', '1d'] },\r\n  \r\n  // Indices\r\n  { symbol: '^GSPC', type: 'index', enabledTimeframes: ['1h', '4h', '1d'] },\r\n  { symbol: '^DJI', type: 'index', enabledTimeframes: ['1h', '4h', '1d'] },\r\n  { symbol: '^IXIC', type: 'index', enabledTimeframes: ['1h', '4h', '1d'] },\r\n]\r\n\r\nexport function inferSignalType(tf: Timeframe): SignalStyle {\r\n  if (tf === '5m') return 'scalp'\r\n  if (tf === '15m' || tf === '1h') return 'intraday'\r\n  return 'swing'\r\n}\r\n"},{"name":"factors.ts","content":"/**\r\n * Factor + candidate types for signal engine (Edge version)\r\n */\r\n\r\nimport { Timeframe } from './config.ts'\r\n\r\nexport type MarketRegime = 'trend' | 'range' | 'breakout'\r\n\r\nexport interface FactorSnapshot {\r\n  symbol: string\r\n  timeframe: Timeframe\r\n  now: Date\r\n  close: number\r\n  ema20: number\r\n  ema50: number\r\n  ema200: number\r\n  rsi14: number\r\n  macdHist: number\r\n  macdHistSlope: number\r\n  atr: number\r\n  atrPct: number\r\n  volume: number | null\r\n  volumeAvg20: number | null\r\n  volumeRatio: number | null\r\n  high20: number\r\n  low20: number\r\n  high50: number\r\n  low50: number\r\n}\r\n\r\nexport interface FactorScores {\r\n  trendScore: number      // 0..1\r\n  momentumScore: number   // 0..1\r\n  volatilityScore: number // 0..1\r\n  volumeScore: number     // 0..1\r\n  structureScore: number  // 0..1\r\n}\r\n\r\nexport interface GeneratedSignalCandidate {\r\n  direction: 'LONG' | 'SHORT'\r\n  score: number\r\n  qualityTier: 'A' | 'B' | 'C'\r\n  entry: number\r\n  stop: number\r\n  target: number\r\n  tp2?: number\r\n  tp3?: number\r\n  rr: number\r\n  regime: MarketRegime\r\n  factors: FactorSnapshot & { factorScores: FactorScores }\r\n  explanation: string\r\n}\r\n"},{"name":"regime.ts","content":"/**\r\n * Market Regime Detection\r\n */\r\n\r\nimport type { FactorSnapshot, MarketRegime } from './factors.ts'\r\n\r\n/**\r\n * Determine regime based on EMAs, volatility expansion, and structure\r\n */\r\nexport function detectRegime(f: FactorSnapshot): MarketRegime {\r\n  const { close, ema50, ema200, high20, low20 } = f\r\n\r\n  const emaAligned =\r\n    (close > ema50 && ema50 > ema200) ||\r\n    (close < ema50 && ema50 < ema200)\r\n\r\n  const emaSpread = Math.abs(ema50 - ema200) / close\r\n\r\n  if (emaAligned && emaSpread > 0.003) {\r\n    return 'trend'\r\n  }\r\n\r\n  const breakingHigh = close >= high20 * 0.998\r\n  const breakingLow = close <= low20 * 1.002\r\n\r\n  if ((breakingHigh || breakingLow) && emaSpread > 0.0015) {\r\n    return 'breakout'\r\n  }\r\n\r\n  return 'range'\r\n}\r\n"},{"name":"scoring.ts","content":"/**\r\n * Factor scoring for signal engine (Edge)\r\n */\r\n\r\nimport type { FactorSnapshot, FactorScores, MarketRegime } from './factors.ts'\r\n\r\nexport function scoreLong(f: FactorSnapshot, regime: MarketRegime): FactorScores {\r\n  let trendScore = 0\r\n  let momentumScore = 0\r\n  let volatilityScore = 0\r\n  let volumeScore = 0\r\n  let structureScore = 0\r\n\r\n  if (f.close > f.ema20 && f.ema20 > f.ema50 && f.ema50 > f.ema200) {\r\n    trendScore = 1\r\n  } else if (f.close > f.ema50 && f.ema50 > f.ema200) {\r\n    trendScore = 0.8\r\n  } else if (f.close > f.ema200) {\r\n    trendScore = 0.5\r\n  }\r\n\r\n  if (regime === 'trend') {\r\n    if (f.rsi14 > 40 && f.rsi14 < 65) momentumScore += 0.6\r\n    if (f.rsi14 < 35 && f.close > f.ema200) momentumScore += 0.4\r\n  } else if (regime === 'range') {\r\n    if (f.rsi14 < 30) momentumScore += 1\r\n    else if (f.rsi14 < 40) momentumScore += 0.7\r\n  } else {\r\n    if (f.rsi14 > 60) momentumScore += 0.8\r\n  }\r\n\r\n  if (f.macdHist > 0 && f.macdHistSlope > 0) {\r\n    momentumScore = Math.min(1, momentumScore + 0.3)\r\n  }\r\n\r\n  if (regime === 'breakout') {\r\n    volatilityScore = f.atrPct > 0.005 ? 1 : 0.4\r\n  } else {\r\n    volatilityScore = f.atrPct < 0.02 && f.atrPct > 0.001 ? 1 : 0.5\r\n  }\r\n\r\n  if (f.volumeRatio && f.volumeRatio > 1.5) volumeScore = 1\r\n  else if (f.volumeRatio && f.volumeRatio > 1) volumeScore = 0.7\r\n  else volumeScore = 0.4\r\n\r\n  if (regime === 'trend') {\r\n    const distToEma20 = Math.abs(f.close - f.ema20) / f.close\r\n    if (distToEma20 < 0.005) structureScore = 1\r\n  }\r\n  if (regime === 'breakout' && f.close > f.high20) structureScore = 1\r\n  if (regime === 'range' && Math.abs(f.close - f.low20) / f.close < 0.01) structureScore = 1\r\n\r\n  return { trendScore, momentumScore, volatilityScore, volumeScore, structureScore }\r\n}\r\n\r\nexport function scoreShort(f: FactorSnapshot, regime: MarketRegime): FactorScores {\r\n  let trendScore = 0\r\n  let momentumScore = 0\r\n  let volatilityScore = 0\r\n  let volumeScore = 0\r\n  let structureScore = 0\r\n\r\n  if (f.close < f.ema20 && f.ema20 < f.ema50 && f.ema50 < f.ema200) {\r\n    trendScore = 1\r\n  } else if (f.close < f.ema50 && f.ema50 < f.ema200) {\r\n    trendScore = 0.8\r\n  } else if (f.close < f.ema200) {\r\n    trendScore = 0.5\r\n  }\r\n\r\n  if (regime === 'trend') {\r\n    if (f.rsi14 > 40 && f.rsi14 < 60) momentumScore += 0.6\r\n    if (f.rsi14 > 65 && f.close < f.ema200) momentumScore += 0.4\r\n  } else if (regime === 'range') {\r\n    if (f.rsi14 > 70) momentumScore += 1\r\n    else if (f.rsi14 > 60) momentumScore += 0.7\r\n  } else {\r\n    if (f.rsi14 < 40) momentumScore += 0.8\r\n  }\r\n\r\n  if (f.macdHist < 0 && f.macdHistSlope < 0) {\r\n    momentumScore = Math.min(1, momentumScore + 0.3)\r\n  }\r\n\r\n  if (regime === 'breakout') {\r\n    volatilityScore = f.atrPct > 0.005 ? 1 : 0.4\r\n  } else {\r\n    volatilityScore = f.atrPct < 0.02 && f.atrPct > 0.001 ? 1 : 0.5\r\n  }\r\n\r\n  if (f.volumeRatio && f.volumeRatio > 1.5) volumeScore = 1\r\n  else if (f.volumeRatio && f.volumeRatio > 1) volumeScore = 0.7\r\n  else volumeScore = 0.4\r\n\r\n  if (regime === 'trend') {\r\n    const distToEma20 = Math.abs(f.close - f.ema20) / f.close\r\n    if (distToEma20 < 0.005) structureScore = 1\r\n  }\r\n  if (regime === 'breakout' && f.close < f.low20) structureScore = 1\r\n  if (regime === 'range' && Math.abs(f.close - f.high20) / f.close < 0.01) structureScore = 1\r\n\r\n  return { trendScore, momentumScore, volatilityScore, volumeScore, structureScore }\r\n}\r\n\r\nexport function calculateTotalScore(scores: FactorScores): number {\r\n  const weighted =\r\n    scores.trendScore * 0.30 +\r\n    scores.momentumScore * 0.30 +\r\n    scores.volatilityScore * 0.15 +\r\n    scores.volumeScore * 0.15 +\r\n    scores.structureScore * 0.10\r\n\r\n  return Math.round(weighted * 100)\r\n}\r\n"},{"name":"indicators.ts","content":"/**\r\n * Technical indicators helper functions for Edge engine\r\n */\r\n\r\nexport interface OHLCV {\r\n  date: string\r\n  open: number\r\n  high: number\r\n  low: number\r\n  close: number\r\n  volume: number\r\n}\r\n\r\nexport function ema(series: number[], period: number): number[] {\r\n  if (series.length < period) return []\r\n\r\n  const multiplier = 2 / (period + 1)\r\n  const result: number[] = []\r\n  let sum = 0\r\n\r\n  for (let i = 0; i < period; i++) {\r\n    sum += series[i]\r\n  }\r\n  result.push(sum / period)\r\n\r\n  for (let i = period; i < series.length; i++) {\r\n    const value = (series[i] - result[result.length - 1]) * multiplier + result[result.length - 1]\r\n    result.push(value)\r\n  }\r\n\r\n  return result\r\n}\r\n\r\nexport function rsi(series: number[], period = 14): number[] {\r\n  if (series.length < period + 1) return []\r\n\r\n  const changes: number[] = []\r\n  for (let i = 1; i < series.length; i++) {\r\n    changes.push(series[i] - series[i - 1])\r\n  }\r\n\r\n  let avgGain = 0\r\n  let avgLoss = 0\r\n\r\n  for (let i = 0; i < period; i++) {\r\n    if (changes[i] > 0) avgGain += changes[i]\r\n    else avgLoss += Math.abs(changes[i])\r\n  }\r\n\r\n  avgGain /= period\r\n  avgLoss /= period\r\n\r\n  const result: number[] = []\r\n  const pushValue = () => {\r\n    if (avgLoss === 0) result.push(100)\r\n    else {\r\n      const rs = avgGain / avgLoss\r\n      result.push(100 - 100 / (1 + rs))\r\n    }\r\n  }\r\n\r\n  pushValue()\r\n\r\n  for (let i = period; i < changes.length; i++) {\r\n    const change = changes[i]\r\n    const gain = change > 0 ? change : 0\r\n    const loss = change < 0 ? Math.abs(change) : 0\r\n\r\n    avgGain = (avgGain * (period - 1) + gain) / period\r\n    avgLoss = (avgLoss * (period - 1) + loss) / period\r\n    pushValue()\r\n  }\r\n\r\n  return result\r\n}\r\n\r\nexport function macd(series: number[], fast = 12, slow = 26, signal = 9) {\r\n  if (series.length < slow + signal) {\r\n    return { line: [], signal: [], histogram: [] }\r\n  }\r\n\r\n  const emaFast = ema(series, fast)\r\n  const emaSlow = ema(series, slow)\r\n  const macdLine: number[] = []\r\n  const offset = emaFast.length - emaSlow.length\r\n\r\n  for (let i = 0; i < emaSlow.length; i++) {\r\n    macdLine.push(emaFast[i + offset] - emaSlow[i])\r\n  }\r\n\r\n  const signalLine = ema(macdLine, signal)\r\n  const histogram = macdLine.slice(signal - 1).map((value, idx) => value - (signalLine[idx] ?? 0))\r\n\r\n  return { line: macdLine.slice(signal - 1), signal: signalLine, histogram }\r\n}\r\n\r\nexport function atr(high: number[], low: number[], close: number[], period = 14): number[] {\r\n  if (high.length < period + 1) return []\r\n\r\n  const trs: number[] = []\r\n  trs.push(high[0] - low[0])\r\n\r\n  for (let i = 1; i < high.length; i++) {\r\n    const tr1 = high[i] - low[i]\r\n    const tr2 = Math.abs(high[i] - close[i - 1])\r\n    const tr3 = Math.abs(low[i] - close[i - 1])\r\n    trs.push(Math.max(tr1, tr2, tr3))\r\n  }\r\n\r\n  const result: number[] = []\r\n  let sum = 0\r\n  for (let i = 0; i < period; i++) sum += trs[i]\r\n  result.push(sum / period)\r\n\r\n  for (let i = period; i < trs.length; i++) {\r\n    const prev = result[result.length - 1]\r\n    result.push((prev * (period - 1) + trs[i]) / period)\r\n  }\r\n\r\n  return result\r\n}\r\n\r\nexport function sma(series: number[], period: number): number[] {\r\n  if (series.length < period) return []\r\n\r\n  const result: number[] = []\r\n  let sum = 0\r\n  for (let i = 0; i < period; i++) sum += series[i]\r\n  result.push(sum / period)\r\n\r\n  for (let i = period; i < series.length; i++) {\r\n    sum = sum - series[i - period] + series[i]\r\n    result.push(sum / period)\r\n  }\r\n\r\n  return result\r\n}\r\n\r\nexport function recentHighLow(high: number[], low: number[], period: number) {\r\n  if (high.length < period) return { highs: [], lows: [] }\r\n\r\n  const highs: number[] = []\r\n  const lows: number[] = []\r\n\r\n  for (let i = period; i <= high.length; i++) {\r\n    const sliceHigh = high.slice(i - period, i)\r\n    const sliceLow = low.slice(i - period, i)\r\n    highs.push(Math.max(...sliceHigh))\r\n    lows.push(Math.min(...sliceLow))\r\n  }\r\n\r\n  return { highs, lows }\r\n}\r\n"},{"name":"deno.json","content":"{\r\n  \"compilerOptions\": {\r\n    \"lib\": [\"deno.window\", \"deno.unstable\"],\r\n    \"strict\": true\r\n  },\r\n  \"imports\": {\r\n    \"@supabase/supabase-js\": \"jsr:@supabase/supabase-js@2\"\r\n  }\r\n}\r\n\r\n"}]